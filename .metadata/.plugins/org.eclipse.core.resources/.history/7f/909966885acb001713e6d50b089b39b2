/*
 * obstacle_avoidance.cpp
 *
 *  Created on: Nov 12, 2017
 *      Author: Jigar
 */

#include "generated_can.h"
#include "obstacle_avoidance.h"
#include  "string.h"

range_type get_left_state(uint16_t left_rdg)
{
	dir_range range = {0};
	if(left_rdg>=0 && left_rdg <=20)
		range.left_range = too_near;
	else if(left_rdg>20 && left_rdg<=45)
		range.left_range = near;
	else if(left_rdg>45 && left_rdg<=110)
		range.left_range = far;
	else if(left_rdg > 110)
		range.left_range = too_far;

	return range.left_range;
}

range_type get_right_state(uint16_t right_rdg)
{
	dir_range range = {0};

	if(right_rdg>=0 && right_rdg <=20)
		range.right_range = too_near;
	else if(right_rdg>20 && right_rdg<=45)
		range.right_range = near;
	else if(right_rdg>45 && right_rdg<=110)
		range.right_range = far;
	else if(right_rdg > 110)
		range.right_range = too_far;

	return range.right_range;
}

range_type get_center_state(uint16_t center_rdg)
{
	dir_range range = {0};

	if(center_rdg>=0 && center_rdg <=40)
		range.center_range = too_near;
	else if(center_rdg>40 && center_rdg<=80)
		range.center_range = near;
	else if(center_rdg>80 && center_rdg<=180)
		range.center_range = far;
	else if(center_rdg > 180)
		range.center_range = too_far;

	return range.center_range;
}

range_type get_rear_state(uint16_t rear_rdg)
{
	dir_range range = {0};
	if(rear_rdg>=0 && rear_rdg <=40)
		range.rear_range = too_near;
	else if(rear_rdg>40 && rear_rdg<=80)
		range.rear_range = near;
	else if(rear_rdg>80 && rear_rdg<=180)
		range.rear_range = far;
	else if(rear_rdg > 180)
		range.rear_range = too_far;

	return range.rear_range;
}

ride_states get_rear_status(range_type rear)
{
	ride_states car_should= stop;
	if(rear == too_near)
		car_should = stop;
	else
		car_should = go_reverse;
	return car_should;
}

ride_states get_turn_status(range_type left, range_type right, range_type rear)
{
	ride_states car_should = stop;

	if((left == too_near) && (right == too_near)) car_should = get_rear_status(rear);
	else if((left == too_near || left == near) && (right >= near)) car_should = turn_right;
	else if((left >= near) && (right == too_near || right == near)) car_should = turn_left;
	else car_should = go_straight;

	return car_should;
}

ride_states get_direction(range_type left, range_type center, range_type right, range_type rear)
{
	ride_states state = stop;
	switch(center)
	{
		case too_near: state = get_rear_status(rear);  break;
			case near:
			case far :
		case too_far : state = get_turn_status(left, right, rear); break;
		default      : state = stop;
	}
	return state;
}

void* set_motor_direction_and_speed(range_type left, range_type center, range_type right, range_type rear)
{
	static MOTOR_SIGNAL_t set_motor= {0};
	ride_states car_state_is = stop;

	// Resetting Structure Members
	memset(&set_motor, 0, sizeof(set_motor));
	car_state_is = get_direction(left, center, right, rear);

	switch(car_state_is)
	{
		case go_straight		:set_motor.MOTOR_DRIVE_FORWARD = 1;
						   		 set_motor.MOTOR_DRIVE_SPEED = 5;
						   		 set_motor.MOTOR_STEER_STRAIGHT =1;break;

		case go_reverse			:set_motor.MOTOR_DRIVE_REVERSE = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 0; //TODO: Set as 5
								 set_motor.MOTOR_STEER_STRAIGHT =1;break;

		case stop				:set_motor.MOTOR_DRIVE_FORWARD = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 0;
								 set_motor.MOTOR_STEER_STRAIGHT =1;break;

		case turn_left			:set_motor.MOTOR_DRIVE_FORWARD = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 5;
								 set_motor.MOTOR_STEER_FULL_LEFT = 1;break;

		case turn_right			:set_motor.MOTOR_DRIVE_FORWARD = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 5;
								 set_motor.MOTOR_STEER_FULL_RIGHT = 1;break;

		case turn_slight_left	:set_motor.MOTOR_DRIVE_FORWARD = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 5;
								 set_motor.MOTOR_STEER_FULL_RIGHT = 1;break;

		case turn_slight_right	:set_motor.MOTOR_DRIVE_FORWARD = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 5;
								 set_motor.MOTOR_STEER_FULL_RIGHT = 1;break;


		default 				:set_motor.MOTOR_DRIVE_FORWARD = 1;
								 set_motor.MOTOR_DRIVE_SPEED = 0;
		 	 	 	 	 //Need to go where gps tells
	}
	return (void *)(&set_motor);
}
